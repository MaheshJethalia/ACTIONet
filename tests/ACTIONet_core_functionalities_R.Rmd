---
title: "Testing core functionalities of the ACTIONet package"
author: 
- Shahin Mohammadi
- Jose Davila-Velderrain
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
---


```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

### Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               eval=T)
opts_knit$set(width=75)
```


```{r setup, include=F}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
	include = TRUE
)

```



Here we provide an in-depth, step-by-step guide to familiarize you with ACTIONet building blocks. For the sake of compatibility, we will use the PBMC 3k dataset used in the [Seurat](https://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html) and [Scanpy](https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html) for this tutorial.



## Preparing the environment

To start, you need to load the ACTIONet package. 

For the ACTIONet installation instruction, see [ACTIONet](https://github.com/shmohammadi86/ACTIONet).

```{r Prepare environment}
require(ACTIONet)

```

# Preparation
## Importing data from a `SingleCellExperiment` object
We have preprocessed and stored the PBMC 3k dataset as an `SCE` object, which is the main datatype used in the ACTIONet framework. For more information on how to convert different datatypes to `SingleCellExperiment` format, please consult our tutorial on [Bring your data along -- Import/export options in ACTIONet](https://github.com/shmohammadi86/ACTIONet/tutorials/Import.html).



```{r}
require(ACTIONet)

sce = readRDS("pbmc3k_sce.RDS")
sce = reduce.sce(sce)

ACTIONet_results = run.ACTIONet(sce, k_max = 20, network_density = 0.5)


ace = ACTIONet_results$ace

plot.ACTIONet(ace, sce$louvain)

```

```{r}

```


```{r}
G = colNets(ace)$ACTIONet
H_stacked = ACTIONet_results$trace$pruning.out$H_stacked
S_r = Matrix::t(reducedDims(ace)[["ACTION"]])

system.time( {X_sgd2 = sgd2_layout_weighted(G = G, S_r = S_r)} ) # 8.226 s
system.time( {X2_sgd2 = sgd2_layout_weighted_convergent(G = G, S_r = S_r)} )
system.time( {X2_sgd2 = sgd2_layout_sparse_weighted(G = G, S_r = S_r, p = 100)} ) # 1s

plot.ACTIONet(ace, coordinate.slot = X2_sgd2, labels = sce$louvain)

```




```{r}
# 
# 
S_r = Matrix::t(reducedDims(ace)[["ACTION"]])

X_sgd2 = sgd2_layout_weighted(G = G, S_r = S_r, t_max = 30)




reducedDims(ace)[["sgd2"]] = X_sgd2
# 
# plot.ACTIONet(ace, labels = sce$louvain)
#

# Use denovo colors
plot.ACTIONet(ace)

# USe known labels
labels = sce$louvain
plot.ACTIONet(ace, labels = labels)

# Use alternative coordinates
plot.ACTIONet(ace, coordinate.slot = "sgd2")
plot.ACTIONet(ace, coordinate.slot = X_sgd2)
plot.ACTIONet(X_sgd2)

plot.ACTIONet(ace, coordinate.slot = "sgd2", labels = labels)
plot.ACTIONet(ace, coordinate.slot = X_sgd2, labels = labels)
plot.ACTIONet(X_sgd2, labels = labels)


# Use transparency to emphasize cool stuff!
## How aggressively to blur?
plot.ACTIONet(ace, labels = labels, transparency.attr = ace$node_centrality, trans.z.threshold = -1)
plot.ACTIONet(ace, labels = labels, transparency.attr = ace$node_centrality, trans.z.threshold = 0)
plot.ACTIONet(ace, labels = labels, transparency.attr = ace$node_centrality, trans.z.threshold = 1)

## How extensively to blur?
plot.ACTIONet(ace, labels = labels, transparency.attr = ace$node_centrality, trans.z.threshold = 0.5, trans.fact = 1)
plot.ACTIONet(ace, labels = labels, transparency.attr = ace$node_centrality, trans.z.threshold = 0.5, trans.fact = 2)
plot.ACTIONet(ace, labels = labels, transparency.attr = ace$node_centrality, trans.z.threshold = 0.5, trans.fact = 3)

# 3D plot
plot.ACTIONet.3D(ace, labels = labels)

# Interactive plot using plot.ly
plot.ACTIONet.interactive(ace)
plot.ACTIONet.interactive(ace, labels = labels)

# Interactive plot using plot.ly (3D)
plot.ACTIONet.interactive(ace, threeD = T)
plot.ACTIONet.interactive(ace, labels = labels, threeD = T)


# Plot footprint
plot.ACTIONet.archetype.footprint(ace)

# Plot gene view
plot.ACTIONet.gene.view(ace, top.genes = 10)

```
```{r}
ace2 = reconstruct.ACTIONet(ace, network_density = 0.5)
ace3 = reconstruct.ACTIONet(ace, network_density = 0.2)
ace4 = reconstruct.ACTIONet(ace, network_density = 0.1)

plot.ACTIONet(ace, sce$Celltypes)
plot.ACTIONet(ace2, sce$Celltypes)
plot.ACTIONet(ace3, sce$Celltypes)
plot.ACTIONet(ace4, sce$Celltypes)


```


```{r}

			
plot.ACTIONet.feature.view <- function(ace, feature.enrichment.table, top.features = 5, CPal = NULL, title = "Feature view", label.text.size = 1, renormalize = F) {
	M = Matrix::t(as(colFactors(ace)[["H_unified"]], 'sparseMatrix'))
	cs = Matrix::colSums(M)
	M = scale(M, center = FALSE, scale = cs)
	
	if(ncol(feature.enrichment.table) != nrow(colFactors(ace)[["H_unified"]])) {
		feature.enrichment.table = Matrix::t(feature.enrichment.table)
	}
	
	if(max(feature.enrichment.table) > 50)
		feature.enrichment.table = log1p(feature.enrichment.table)

	X = t(select.top.k.features(feature.enrichment.table, 3, normalize = renormalize, reorder.columns = F))
	selected.features = colnames(X)
	
	print(X)
	
	Z = Z = t(scale(reducedDims(ace)[["ACTIONet2D"]]))
	core.coors = t(Z %*% M)

	cs = colSums(X)
	cs[cs == 0] = 1
	X = scale(X, center = F, scale = cs)
	feature.coors = scale(t(X) %*% core.coors)
	print(feature.coors)
	
    if (is.null(CPal)) {
        #Pal = ace$unification.out$Pal
			cells.Lab = grDevices::convertColor(color = Matrix::t(colFactors(ace)$denovo_color), from = "sRGB", to = "Lab")
			arch.Lab = Matrix::t(M) %*% cells.Lab			
			arch.RGB = grDevices::convertColor(color = arch.Lab, from = "Lab", to = "sRGB")
			core.Pal = rgb(arch.RGB)
    } else {
    	if(length(CPal) == 1) {
            core.Pal = ggpubr::get_palette(CPal, length(unique(ace$archetype.assignment)))
    	} else {
            core.Pal = CPal[1:length(unique(ace$archetype.assignment))]
    	}
    }
    core.Lab = grDevices::convertColor(color = t(col2rgb(core.Pal)/256), from = "sRGB", to = "Lab")
    
    feature.color.Lab = t(X) %*% core.Lab

    feature.colors = rgb(grDevices::convertColor(color = feature.color.Lab, from = "Lab", to = "sRGB"))
    names(feature.colors) = selected.features


	x = feature.coors[, 1]
	y = feature.coors[, 2]
    plot (x, y, type = "n", col = feature.colors, axes = FALSE, xlab = "", ylab = "", main = title)

	words = selected.features
    lay <- wordlayout(x, y, words, label.text.size)
    for (i in 1:length(x)) {
        xl <- lay[i, 1]
        yl <- lay[i, 2]
        w <- lay[i, 3]
        h <- lay[i, 4]
        if (x[i] < xl || x[i] > xl + w || y[i] < yl || y[i] > 
            yl + h) {
            points(x[i], y[i], pch = 16, col = colorspace::darken(feature.colors[[i]], 0.6), cex = 0.75*label.text.size)
            nx <- xl + 0.5 * w
            ny <- yl + 0.5 * h
            lines(c(x[i], nx), c(y[i], ny), col = colorspace::darken(feature.colors[[i]], 0.5))
        }
    }
    #plot.new()
    loc.x = lay[, 1] + 0.5 * lay[, 3]
    loc.y = lay[, 2] + 0.5 * lay[, 4]
    text(loc.x, loc.y, words, col = feature.colors, cex = label.text.size)

}

plot.ACTIONet.gene.view <- function(ace, top.genes = 5, CPal = NULL, blacklist.pattern = "\\.|^RPL|^RPS|^MRP|^MT-|^MT|^RP|MALAT1|B2M|GAPDH", title = "", label.text.size = 0.8, renormalize = F) {
	require(wordcloud)
	
	feature.enrichment.table = as.matrix(rowFactors(ace)[["H_unified_upper_significance"]])
	
	filtered.rows = grep(blacklist.pattern, rownames(feature.enrichment.table))
	if(length(filtered.rows) > 0)
		feature.enrichment.table = feature.enrichment.table[-filtered.rows, ]
	
	plot.ACTIONet.feature.view(ace, feature.enrichment.table, title = "Gene view", renormalize = renormalize)
}

```


```{r}
sce = readRDS("pbmc3k_sce.RDS")


sce

```


## Reducing the `SCE` object
Next, we use the `reduce.sce()` function to both normalize the counts' matrix (lib-size normalization + log-transformation, by default) and compute a factorized (reduced) form  of the kernel matrix (50 by default). By default, no batch correction is performed, and the simplest depth-normalization method is used. We then save the output for future use.


```{r Reduce SCE object}
sce = reduce.sce(sce = sce)

S_r = t(reducedDims(sce)[["ACTION"]])
S = logcounts(sce)

```


**PS**: ACTIONet includes 7 additional normalization methods (scran, linnorm, scone, SCnorm, DESeq2, TMM, and logCPM). However, the `default` method is the fastest and performs very well for ACTIONet construction. 

**PS**: ACTIONet also seamlessly integrates with [Harmony](https://github.com/immunogenomics/harmony) batch-correction method. For more information on how to use batch correction please consult [To batch correct or not to batch correct, that is the question!](https://github.com/shmohammadi86/ACTIONet/tutorials/Batch.html).

## Creating an `ACTIONetExperiment (ACE)` object to hold results
We have extended the `SingleCellExperiment` class to incorporate additional slots, similar to `AnnData` format, to hold multidimensional and structural meta-data for rows and columns. To construct an `ACE` object from an `SCE` object, we run

```{r}
ace = as(sce, "ACTIONetExperiment")

ace

```
As it can be seen, the new slots are `rowNets`, `colNets`, `rowFactors`, and `colFactors`. Each slot has its on getter/setter functions, which we will use through out the rest of the tutorial to store results.


# Running ACTIONet

## Running multi-level ACTION decomposition
This will run ACTIONet with increasing number of archetypes
```{r}
ACTION.out = run_ACTION(S_r, k_max = 30, thread_no =8, max_it = 50, min_delta = 1e-9)


```

## Prune nonspecific and/or unreliable archetypes
To remove unreliable archetypes and a first pass filtering, we can use `prune_archetypes()` function:

```{r}
pruning.out = prune_archetypes(ACTION.out$C, ACTION.out$H)


C_stacked = pruning.out$C_stacked
H_stacked = pruning.out$H_stacked

# 
H_stacked = do.call(rbind, ACTION.out$H[-1])
C_stacked = do.call(cbind, ACTION.out$C[-1])

colFactors(ace)[["C_stacked"]] = Matrix::t(C_stacked)
colFactors(ace)[["H_stacked"]] = H_stacked

```

`C_stacked` and `H_stacked` are the concatenated `C` and `H` matrices across different levels, respectively, after pruning noisy archetypes.



## Building ACTIONet graph
```{r}
set.seed(0)
G = build_ACTIONet(H_stacked = H_stacked,  thread_no=8)

```

To store computed graph as a network associated with cells (columns) in the `ACE` object, we can use:

```{r}
	colNets(ace)$ACTIONet = G

```

	
	
## Layout ACTIONet
We have adopted and modified the SGD-based layout algorithm utilized in the *UMAP* for our visualization. We use `S_r` for our initialization:

```{r}
	initial.coordinates = t(scale(t(S_r)))
    vis.out = layout_ACTIONet(G, S_r = initial.coordinates, n_epochs = 500)
    
```

And then we can store the coordinates as `reducedDims()` and computed *de novo* colors as attributes in the `colData()`:

```{r}
    reducedDims(ace)$ACTIONet2D = vis.out$coordinates
    reducedDims(ace)$ACTIONet3D = vis.out$coordinates_3D
    colFactors(ace)$denovo_color = Matrix::t(vis.out$colors)
    
	
```


## Identiy equivalent classes of archetypes and group them together
There is a large redundancy between the set of archetypes. `unify_archetypes()` tries to coalesce these archetypes and partition them into equivalent classes.

```{r}
	archs = as.matrix(S %*% C_stacked)
	unification.out = unify_archetypes(G, S_r, archs, pruning.out$C_stacked, pruning.out$H_stacked, minPoints = 10, minClusterSize = 10, outlier_threshold = 0.0)

```

And store the results back in the `ACE` object:
```{r}
	colFactors(ace)[["C_unified"]] = t(unification.out$C_unified)
	colFactors(ace)[["H_unified"]] = unification.out$H_unified
	ace$assigned_archetype = unification.out$assigned_archetype
	
```


## Use graph core of global and induced subgraphs to infer centrality/quality of each cell
We have developed a novel technique to estimate the quality of cells based on the strategic placement in the ACTIONet, w.r.t to each archetype:

```{r}
ace$node_centrality = compute_archetype_core_centrality(G, ace$assigned_archetype)

```


	
## Compute gene specificity for each archetype
This computes the "marker-ness" of each genes for different archetypes:

```{r}
	S = logcounts(ace)
	## Core/unified archetypes only
	specificity.out = compute_archetype_feature_specificity_full(S, unification.out$H_unified)
	specificity.out = lapply(specificity.out, function(specificity.scores) {
		rownames(specificity.scores) = rownames(ace)
		colnames(specificity.scores) = paste("A", 1:ncol(specificity.scores))
		return(specificity.scores)
	})
	rowFactors(ace)[["H_unified_profile"]] = specificity.out[["archetypes"]]
	rowFactors(ace)[["H_unified_upper_significance"]] = specificity.out[["upper_significance"]]
	rowFactors(ace)[["H_unified_lower_significance"]] = specificity.out[["lower_significance"]]
	
```


## Creating a trace of all that we have done	
```{r}
	trace = list(ACTION.out = ACTION.out, pruning.out = pruning.out, vis.out = vis.out, unification.out = unification.out)
    trace$log = list(genes = rownames(ace), cells = colnames(ace), time = Sys.time())
    
```

## Visualization
### Compare plots
```{r}
plot.ACTIONet(ace, ace$louvain, reduction.slot = "pca", title = "pca")

plot.ACTIONet(ace, ace$louvain, reduction.slot = "draw_graph_fr", title = "ForceDirected")

plot.ACTIONet(ace, ace$louvain, reduction.slot = "tsne", title = "tSNE")

plot.ACTIONet(ace, ace$louvain, reduction.slot = "umap", title = "UMAP")

plot.ACTIONet(ace, ace$louvain, reduction.slot = "ACTIONet2D", title = "ACTIONet", transparency.attr = ace$node_centrality, trans.fact = 1)

```
```{r}
plot.ACTIONet(ace)

```


